"""
‚ôªÔ∏è Module: dup_display.py

This module provides the notebook-facing display renderer for the M04 Duplicates
pipeline. It generates a rich, interactive HTML dashboard summarizing the
deduplication results. The dashboard dynamically adapts to show either flagged
or removed duplicates, includes summary statistics, and can display plots for
visual analysis.
"""

from IPython.display import display, HTML
import pandas as pd
from analyst_toolkit.m00_utils.rendering_utils import to_html_table
from analyst_toolkit.m00_utils.plot_viewer import PlotViewer
import ipywidgets as widgets

def display_dupes_summary(report: dict, subset_cols: list, plot_paths: dict = None):
    """
    Renders a single, consolidated HTML dashboard for the deduplication results.

    Args:
        report (dict): A dictionary of DataFrames generated by the reporting module.
                       Expected keys include 'summary', 'dropped_rows' (for remove mode),
                       and 'duplicate_clusters' (for flag mode).
        subset_cols (list): The list of columns used as criteria for deduplication.
        plot_paths (dict, optional): A dictionary of paths to saved plots for visualization.
    """
    summary_df = report.get("summary")
    if summary_df is None or summary_df.empty:
        display(HTML("<h4>‚ôªÔ∏è Deduplication Summary</h4><p><em>No duplicate handling was performed or no changes were made.</em></p>"))
        return

    # --- 1. Banner ---
    # Determine mode from the report content to build the correct banner
    is_remove_mode = 'Rows Removed' in summary_df['Metric'].values

    def _safe_metric(df: pd.DataFrame, name: str) -> int:
        try:
            series = df.loc[df['Metric'] == name, 'Value']
            return int(series.iloc[0]) if not series.empty else 0
        except Exception:
            return 0

    if is_remove_mode:
        rows_changed = _safe_metric(summary_df, 'Rows Removed')
        banner_metric = f"<strong>Rows Removed:</strong> {rows_changed}"
    else:  # flag mode
        rows_changed = _safe_metric(summary_df, 'Duplicate Rows Flagged')
        # If no explicit metric present (e.g., no duplicates case), default nicely to 0
        banner_metric = f"<strong>Rows Flagged:</strong> {rows_changed}"

    status_emoji = "‚úÖ" if rows_changed == 0 else "‚ö†Ô∏è"
    criteria_str = f"`{'`, `'.join(subset_cols)}`" if subset_cols else 'all columns'
    
    banner_html = f"""
    <div style="border: 1px solid #d0d7de; background-color: #eef2f7; color: #24292e; padding: 12px; border-radius: 6px; margin-bottom: 20px;">
        <strong>Stage:</strong> M04 Deduplication {status_emoji} | 
        {banner_metric} |
        <strong>Criteria:</strong> Based on {criteria_str}
    </div>"""

    # --- 2. Summary Table ---
    summary_table_html = to_html_table(summary_df, full_preview=True)
    summary_block = f"<details open><summary><strong>üìà Summary of Changes</strong></summary><div style='margin-top: 1em;'>{summary_table_html}</div></details>"

    # --- 3. Duplicate Details (Flagged or Dropped) ---
    details_df = None
    details_block = ""
    clusters_block = ""

    def _build_subset_clusters_blocks(clusters_df: pd.DataFrame, subset_cols: list) -> str:
        """Return HTML blocks focused on the chosen subset: key summary + subset-only rows."""
        if clusters_df is None or clusters_df.empty:
            return ""
        if subset_cols:
            # 1) Duplicate keys with counts (n >= 2)
            try:
                key_counts = clusters_df.groupby(subset_cols).size().reset_index(name='count')
                key_counts = key_counts[key_counts['count'] >= 2].sort_values(
                    by=(['count'] + subset_cols), ascending=([False] + [True]*len(subset_cols))
                )
            except Exception:
                key_counts = None
            key_counts_html = to_html_table(key_counts, max_rows=20) if key_counts is not None and not key_counts.empty else "<p><em>No duplicate keys found.</em></p>"

            # 2) Row-level subset-only view
            try:
                subset_only = clusters_df[subset_cols].sort_values(by=subset_cols)
            except Exception:
                subset_only = clusters_df
            subset_only_html = to_html_table(subset_only, max_rows=20)

            return f"""
            <details open>
                <summary><strong>üîë Duplicate Keys (subset only)</strong></summary>
                <div style=\"max-height: 300px; overflow-y: auto; margin-top: 1em; padding-top: 4px;\">
                    {key_counts_html}
                </div>
            </details>
            <details>
                <summary><strong>üìã Duplicate Rows (subset columns only)</strong></summary>
                <div style=\"max-height: 400px; overflow-y: auto; margin-top: 1em; padding-top: 4px;\">
                    {subset_only_html}
                </div>
            </details>
            """
        else:
            clusters_html = to_html_table(clusters_df, max_rows=20)
            return f"""
            <details open>
                <summary><strong>üîç Duplicate Clusters Found (click to scroll)</strong></summary>
                <div style=\"max-height: 400px; overflow-y: auto; margin-top: 1em; padding-top: 4px;\">
                    {clusters_html}
                </div>
            </details>
            """

    if is_remove_mode:
        # In remove mode, show what was dropped and provide full clusters for context.
        dropped_df = report.get("dropped_rows")
        if dropped_df is not None and not dropped_df.empty:
            details_html = to_html_table(dropped_df, max_rows=20)
            details_block = f"""
            <details open>
                <summary><strong>üîç Dropped Duplicate Rows (click to scroll)</strong></summary>
                <div style="max-height: 400px; overflow-y: auto; margin-top: 1em; padding-top: 4px;">
                    {details_html}
                </div>
            </details>
            """
        
        all_duplicates_df = report.get("all_duplicate_instances")
        if all_duplicates_df is not None and not all_duplicates_df.empty:
            clusters_block = _build_subset_clusters_blocks(all_duplicates_df, subset_cols)
    else: # flag mode
        # In flag mode, the main detail to show is the clusters of duplicates found.
        clusters_df = report.get("duplicate_clusters")
        if clusters_df is not None and not clusters_df.empty:
            details_block = _build_subset_clusters_blocks(clusters_df, subset_cols)
    
    # --- 4. Assemble and Display all HTML content at once ---
    final_html = f"<div>{banner_html}{summary_block}{details_block}{clusters_block}</div>"
    display(HTML(final_html))

    # --- 5. Display the Interactive Widget Separately ---
    if plot_paths:
        viewer = PlotViewer(plot_paths, title="Visual Summary")
        accordion = widgets.Accordion(children=[viewer.widget_box])
        accordion.set_title(0, 'üñºÔ∏è Duplication Visual Summary')
        accordion.selected_index = 0 # Start open
        display(accordion)
